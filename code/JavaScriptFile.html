<script>
  // Global variables
  let spreadsheetData = {
    id: '',              // Spreadsheet ID (used internally only)
    name: '',            // Name of the spreadsheet
    url: '',             // Complete spreadsheet URL as entered by user
    sheetName: '',       // Selected sheet name
    columnHeaders: [],   // Array of column headers from selected sheet
    emailColumn: '',     // Column containing recipient email addresses
    ccColumn: '',        // Column containing CC addresses (optional)
    bccColumn: '',       // Column containing BCC addresses (optional)
    validationResults: null, // Results of validation operations
    recipientCount: 0    // Number of recipients found in email column
  };
  
  // Global variable to store quota information (with safe defaults)
  let quotaInfo = {
    remaining: 0,
    total: 100,
    used: 0,
    hasPermission: true
  };
  
  // Configuration
  const config = {
    subjectCharLimit: 60,
    subjectWarningThreshold: 0.8, // Show warning at 80% of limit
    toastDuration: 5000,
    showTooltips: true
  };
  
  // Validation levels
  const ValidationLevel = {
    NONE: 0,
    BASIC: 1,   // Spreadsheet validated
    TEST: 2,    // Sheet selected
    FULL: 3     // Email column selected and recipients found
  };
  
  // Debounce helper function
  function debounce(func, wait) {
    let timeout;
    return function() {
      const context = this;
      const args = arguments;
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(context, args), wait);
    };
  }

  // Function to toggle sections open/closed
  function toggleSection(sectionId) {
    // Get all sections
    const sections = document.querySelectorAll('.section');
    
    // Get the clicked section
    const clickedSection = document.getElementById(sectionId);
    
    // Check if the section is already active (open)
    const isActive = clickedSection.classList.contains('active');
    
    // If it's already active, close it
    if (isActive) {
      clickedSection.classList.remove('active');
      const toggleIndicator = clickedSection.querySelector('.toggle-indicator');
      if (toggleIndicator) {
        toggleIndicator.innerHTML = '+';
        clickedSection.querySelector('.section-header').setAttribute('aria-expanded', 'false');
      }
    } else {
      // Remove active class from all sections
      sections.forEach(section => {
        section.classList.remove('active');
        
        // Update toggle indicator
        const toggleIndicator = section.querySelector('.toggle-indicator');
        if (toggleIndicator) {
          toggleIndicator.innerHTML = '+';
          section.querySelector('.section-header').setAttribute('aria-expanded', 'false');
        }
      });
      
      // Add active class to clicked section
      clickedSection.classList.add('active');
      
      // Update toggle indicator
      const toggleIndicator = clickedSection.querySelector('.toggle-indicator');
      if (toggleIndicator) {
        toggleIndicator.innerHTML = '−';
        clickedSection.querySelector('.section-header').setAttribute('aria-expanded', 'true');
      }
    }
  }
  
  // Function to show or hide an element
  function toggleVisibility(elementId, isVisible) {
    const element = document.getElementById(elementId);
    if (element) {
      if (isVisible) {
        element.classList.remove('hidden');
      } else {
        element.classList.add('hidden');
      }
    }
  }
  
  // Function to toggle tooltip visibility
  function toggleTooltips(show) {
    config.showTooltips = show;
    document.querySelectorAll('.help-icon').forEach(icon => {
      if (show) {
        icon.style.display = '';
      } else {
        icon.style.display = 'none';
      }
    });
  }
  
  // Function to toggle quota panel visibility
  function toggleQuotaPanel() {
    const panel = document.getElementById('quotaDetailPanel');
    if (!panel) return; // Safety check
    
    const isVisible = !panel.classList.contains('hidden');
    const expandIcon = document.getElementById('quotaExpandIcon');
    
    if (isVisible) {
      panel.classList.add('hidden');
      if (expandIcon) expandIcon.textContent = '▼';
    } else {
      panel.classList.remove('hidden');
      if (expandIcon) expandIcon.textContent = '▲';
      
      // Refresh quota info when expanding
      loadQuotaInfo();
    }
  }

  // Function to load quota information from the server
  function loadQuotaInfo() {
    // Safely check if element exists
    const statusText = document.getElementById('quotaStatusText');
    if (statusText) {
      statusText.textContent = 'Loading...';
    }
    
    google.script.run
      .withSuccessHandler(function(result) {
        // Store quota info
        quotaInfo = result || { hasPermission: false };
        
        // Debug info
        console.log('Received quota info:', JSON.stringify(result));
        
        // Update UI with quota information
        updateQuotaDisplay();
      })
      .withFailureHandler(function(error) {
        // Handle error
        console.error('Error loading quota info:', error);
        if (statusText) {
          statusText.textContent = 'Error';
        }
      })
      .getEmailQuotaInfo();
  }

  // Function to update the quota display with current information
  function updateQuotaDisplay() {
    // Safety check for missing elements
    const quotaStatusText = document.getElementById('quotaStatusText');
    const quotaPermissionError = document.getElementById('quotaPermissionError');
    const quotaDetailedInfo = document.getElementById('quotaDetailedInfo');
    
    // If elements are missing, don't proceed
    if (!quotaStatusText || !quotaPermissionError || !quotaDetailedInfo) {
      console.warn('Quota display elements missing');
      return;
    }
    
    // Check if we have permission to access quota information
    if (!quotaInfo.hasPermission) {
      // Show permission error
      quotaStatusText.textContent = '⚠ Unknown';
      quotaStatusText.style.color = '#f9ab00';
      
      // Show permission error notice
      quotaPermissionError.classList.remove('hidden');
      
      // Hide the bars and details that we can't calculate
      quotaDetailedInfo.classList.add('hidden');
      
      return;
    }
    
    // Hide permission error if we have permission
    quotaPermissionError.classList.add('hidden');
    quotaDetailedInfo.classList.remove('hidden');
    
    // Get necessary data with safe defaults
    const recipientCount = spreadsheetData.recipientCount || 0;
    const remaining = quotaInfo.remaining || 0;
    const total = quotaInfo.total || 100;
    const used = quotaInfo.used || 0;
    
    // Debug log the values
    console.log('Quota values:', { remaining, total, used, recipientCount });
    
    // Calculate percentages correctly
    const usedPercentage = total > 0 ? Math.round((used / total) * 100) : 0;
    const willUsePercentage = total > 0 ? Math.round((recipientCount / total) * 100) : 0;
    const afterMergeRemaining = remaining - recipientCount;
    const willExceedQuota = recipientCount > remaining;
    const afterMergePercentage = Math.min(100, usedPercentage + willUsePercentage);
    
    // Update status text and color
    if (willExceedQuota) {
      quotaStatusText.textContent = '⚠ Warning';
      quotaStatusText.style.color = '#ea4335';
    } else {
      quotaStatusText.textContent = '✓ OK';
      quotaStatusText.style.color = '#34a853';
    }
    
    // Safely update UI elements
    const elements = {
      'quotaTotalLimit': total + ' emails',
      'quotaAvailable': remaining + ' emails',
      'quotaMergeCount': recipientCount + ' emails',
      'quotaCurrentPercentage': usedPercentage + '%',
      'quotaProjectedPercentage': afterMergePercentage + '%'
    };
    
    // Update text elements if they exist
    for (const [id, value] of Object.entries(elements)) {
      const element = document.getElementById(id);
      if (element) element.textContent = value;
    }
    
    // Update "Remaining After" field
    const afterMergeEl = document.getElementById('quotaAfterMerge');
    if (afterMergeEl) {
      if (willExceedQuota) {
        afterMergeEl.textContent = 'Exceeds by ' + Math.abs(afterMergeRemaining);
        afterMergeEl.style.color = '#ea4335';
      } else {
        afterMergeEl.textContent = afterMergeRemaining + ' emails';
        afterMergeEl.style.color = '';
      }
    }
    
    // Update progress bars if they exist
    const bars = {
      'quotaCurrentBar': usedPercentage + '%',
      'quotaCurrentBar2': usedPercentage + '%'
    };
    
    for (const [id, width] of Object.entries(bars)) {
      const element = document.getElementById(id);
      if (element) element.style.width = width;
    }
    
    // Update projected bar
    const projectedBar = document.getElementById('quotaProjectedBar');
    if (projectedBar) {
      projectedBar.style.width = willUsePercentage + '%';
      projectedBar.style.marginLeft = usedPercentage + '%';
    }
    
    // Show/hide warning
    const warningEl = document.getElementById('quotaWarning');
    const warningText = document.getElementById('quotaWarningText');
    
    if (warningEl && warningText) {
      if (willExceedQuota) {
        warningEl.classList.remove('hidden');
        warningText.textContent = 
          `This mail merge will exceed your daily quota by ${recipientCount - remaining} emails.`;
      } else {
        warningEl.classList.add('hidden');
      }
    }
  }
  
  // Helper function to check validation level and update UI
  function getValidationLevel() {
    if (!spreadsheetData.id || !spreadsheetData.url) {
      return ValidationLevel.NONE;
    }
    
    if (!spreadsheetData.sheetName) {
      return ValidationLevel.BASIC;
    }
    
    if (!spreadsheetData.emailColumn || spreadsheetData.recipientCount <= 0) {
      return ValidationLevel.TEST;
    }
    
    return ValidationLevel.FULL;
  }
  
  // Update button states based on validation level
  function updateButtonStates() {
    const level = getValidationLevel();
    
    // Update send test email button
    const sendPreviewBtn = document.getElementById('sendPreviewBtn');
    if (sendPreviewBtn) {
      sendPreviewBtn.disabled = level < ValidationLevel.TEST;
    }
    
    // Update send emails button
    const executeBtn = document.getElementById('executeBtn');
    if (executeBtn) {
      executeBtn.disabled = level < ValidationLevel.FULL;
    }
    
    // Update spreadsheet info display
    updateSpreadsheetInfoDisplay();
  }
  
  // Function to update spreadsheet info display
  function updateSpreadsheetInfoDisplay() {
    const infoBox = document.getElementById('spreadsheetInfoBox');
    if (!infoBox) return;
    
    if (!spreadsheetData.url) {
      infoBox.classList.add('hidden');
      return;
    }
    
    // Show info box
    infoBox.classList.remove('hidden');
    
    // Update spreadsheet name
    const nameEl = document.getElementById('spreadsheetName');
    if (nameEl) {
      nameEl.textContent = spreadsheetData.name || 'Unknown Spreadsheet';
    }
    
    // Update spreadsheet URL (truncated for display)
    const urlEl = document.getElementById('spreadsheetUrl');
    if (urlEl) {
      const displayUrl = spreadsheetData.url.length > 40 ? 
                         spreadsheetData.url.substring(0, 37) + '...' : 
                         spreadsheetData.url;
      urlEl.textContent = displayUrl;
      urlEl.title = spreadsheetData.url;
      urlEl.href = spreadsheetData.url;
    }
    
    // Update sheet name if available
    const sheetEl = document.getElementById('spreadsheetSheet');
    if (sheetEl) {
      if (spreadsheetData.sheetName) {
        sheetEl.textContent = spreadsheetData.sheetName;
        sheetEl.classList.remove('hidden');
      } else {
        sheetEl.classList.add('hidden');
      }
    }
    
    // Update validation status
    const validationLevelEl = document.getElementById('validationLevel');
    if (validationLevelEl) {
      const level = getValidationLevel();
      let statusText, statusClass;
      
      switch(level) {
        case ValidationLevel.NONE:
          statusText = 'Not Validated';
          statusClass = 'status-none';
          break;
        case ValidationLevel.BASIC:
          statusText = 'Basic Validation';
          statusClass = 'status-basic';
          break;
        case ValidationLevel.TEST:
          statusText = 'Test Ready';
          statusClass = 'status-test';
          break;
        case ValidationLevel.FULL:
          statusText = 'Ready to Send';
          statusClass = 'status-full';
          break;
      }
      
      validationLevelEl.textContent = statusText;
      
      // Remove all status classes
      validationLevelEl.classList.remove('status-none', 'status-basic', 'status-test', 'status-full');
      
      // Add current status class
      validationLevelEl.classList.add(statusClass);
    }
  }

  // Function to validate spreadsheet
  function validateSpreadsheet() {
    const spreadsheetUrl = document.getElementById('spreadsheetUrl').value.trim();
    if (!spreadsheetUrl) {
      showNotification('Please enter a spreadsheet URL or ID', 'error', config.toastDuration);
      return;
    }
    
    // Store the full URL in spreadsheetData
    spreadsheetData.url = spreadsheetUrl;
    
    // Show loading state
    const validateBtn = document.getElementById('validateBtn');
    validateBtn.disabled = true;
    
    // Change button text to show we're processing
    const originalBtnText = validateBtn.innerHTML;
    validateBtn.innerHTML = `<span class="spinner" style="width: 12px; height: 12px; margin-right: 4px;"></span> Validating...`;
    
    // Show loading notification
    const loadingNotification = showNotification('Validating spreadsheet...', 'info', 0);
    
    // Call the server-side validation function
    google.script.run
      .withSuccessHandler(function(result) {
        // Restore button state
        validateBtn.innerHTML = originalBtnText;
        validateBtn.disabled = false;
        
        // Remove loading notification
        if (loadingNotification) {
          loadingNotification.remove();
        }
        
        // Handle successful validation
        if (result.success) {
          // Store the spreadsheet data (ID internally, URL preserved)
          spreadsheetData.id = result.id;
          spreadsheetData.name = result.name;
          
          // Show notification for successful validation
          showNotification(`Spreadsheet "${result.name}" successfully validated`, 'success', config.toastDuration);
          
          // Show the Load Sheets button and spreadsheet info
          toggleVisibility('loadSheetsGroup', true);
          
          // Update spreadsheet info display
          updateSpreadsheetInfoDisplay();
          
          // Apply pending configuration if this is after loading a config
          if (window.pendingConfiguration && window.pendingConfiguration.sheetName) {
            showNotification('Continue by clicking "Load Sheets"', 'info', config.toastDuration);
          }
          
          // Update button states
          updateButtonStates();
        } else {
          showNotification(result.message || 'Error validating spreadsheet', 'error', config.toastDuration);
        }
      })
      .withFailureHandler(function(error) {
        // Restore button state
        validateBtn.innerHTML = originalBtnText;
        validateBtn.disabled = false;
        
        // Remove loading notification
        if (loadingNotification) {
          loadingNotification.remove();
        }
        
        // Show error
        showNotification('Error validating spreadsheet: ' + (error.message || 'Unknown error'), 'error', config.toastDuration);
      })
      .validateSpreadsheet(spreadsheetUrl);
  }

  // Function to load sheet names - now called manually via button click
  function loadSheetNames() {
    // Show loading notification
    const loadingNotification = showNotification('Loading sheets...', 'info', 0);
    
    // Show loading state on button
    const loadSheetsBtn = document.getElementById('loadSheetsBtn');
    loadSheetsBtn.disabled = true;
    const btnText = loadSheetsBtn.textContent || loadSheetsBtn.innerText;
    loadSheetsBtn.innerHTML = `<span class="spinner" style="width: 12px; height: 12px; margin-right: 4px;"></span> ${btnText}`;
    
    google.script.run
      .withSuccessHandler(function(sheetNames) {
        // Remove loading notification
        if (loadingNotification) {
          loadingNotification.remove();
        }
        
        // Restore button state
        loadSheetsBtn.innerHTML = btnText;
        loadSheetsBtn.disabled = false;
        
        // Handle the result
        handleSheetNames(sheetNames);
      })
      .withFailureHandler(function(error) {
        // Remove loading notification
        if (loadingNotification) {
          loadingNotification.remove();
        }
        
        // Restore button state
        loadSheetsBtn.innerHTML = btnText;
        loadSheetsBtn.disabled = false;
        
        // Show error
        showNotification('Error loading sheets: ' + (error.message || 'Unknown error'), 'error', config.toastDuration);
      })
      .getSheetNames(spreadsheetData.id);
  }

  // Handler for sheet names
  function handleSheetNames(sheetNames) {
    const sheetSelect = document.getElementById('sheetSelect');
    
    // Clear existing options
    sheetSelect.innerHTML = '<option value="">Select a sheet...</option>';
    
    // Add options for each sheet
    sheetNames.forEach(sheetName => {
      if (!sheetName.startsWith('Error:')) {
        const option = document.createElement('option');
        option.value = sheetName;
        option.textContent = sheetName;
        sheetSelect.appendChild(option);
      } else {
        showNotification(sheetName, 'error', config.toastDuration);
      }
    });
    
    // Show the sheet select group
    toggleVisibility('sheetSelectGroup', true);
    
    // Apply pending configuration if available
    if (window.pendingConfiguration && window.pendingConfiguration.sheetName) {
      selectOptionByValue(sheetSelect, window.pendingConfiguration.sheetName);
      showNotification('Sheet selected. Click "Load Columns" to continue.', 'info', config.toastDuration);
      toggleVisibility('loadColumnsGroup', true);
    }
    
    // Show the Load Columns button after sheet selection
    document.getElementById('sheetSelect').addEventListener('change', function() {
      const selectedSheet = this.value;
      if (selectedSheet) {
        // Store the selected sheet name
        spreadsheetData.sheetName = selectedSheet;
        
        // Update summary
        document.getElementById('summarySheet').textContent = selectedSheet;
        
        // Show the Load Columns button
        toggleVisibility('loadColumnsGroup', true);
        
        // Update spreadsheet info display
        updateSpreadsheetInfoDisplay();
        
        // Update button states
        updateButtonStates();
      } else {
        toggleVisibility('loadColumnsGroup', false);
      }
    });
    
    // Show success notification
    showNotification('Sheets loaded successfully', 'success', config.toastDuration);
  }

  // Function to load sheet columns
  function loadSheetColumns() {
    const sheetName = document.getElementById('sheetSelect').value;
    if (!sheetName) {
      showNotification('Please select a sheet first', 'error', config.toastDuration);
      return;
    }
    
    // Show loading state on button
    const loadColumnsBtn = document.getElementById('loadColumnsBtn');
    loadColumnsBtn.disabled = true;
    const btnText = loadColumnsBtn.textContent || loadColumnsBtn.innerText;
    loadColumnsBtn.innerHTML = `<span class="spinner" style="width: 12px; height: 12px; margin-right: 4px;"></span> ${btnText}`;
    
    // Show loading notification
    const loadingNotification = showNotification('Loading columns...', 'info', 0);
    
    // Reset visibility state of dropdown containers
    toggleVisibility('emailColumnGroup', false);
    toggleVisibility('ccColumnGroup', false);
    toggleVisibility('bccColumnGroup', false);
    toggleVisibility('ccBccToggleGroup', false);
    toggleVisibility('validationStatusGroup', false);
    
    // Call the server function
    google.script.run
      .withSuccessHandler(function(result) {
        // Remove loading notification
        if (loadingNotification) {
          loadingNotification.remove();
        }
        
        // Restore button state
        loadColumnsBtn.innerHTML = btnText;
        loadColumnsBtn.disabled = false;
        
        // Show success notification
        showNotification('Columns loaded successfully', 'success', config.toastDuration);
        
        // Handle the result
        handleSheetColumns(result.headers);
        
        // Ensure these are explicitly shown
        toggleVisibility('emailColumnGroup', true);
        toggleVisibility('ccBccToggleGroup', true);
        
        // Store recipient count if available (will be 0 initially)
        spreadsheetData.recipientCount = result.recipientCount || 0;
        document.getElementById('summaryRecipientCount').textContent = 
          result.recipientCount ? result.recipientCount : '-';
          
        // Update quota display with new recipient count
        updateQuotaDisplay();
        
        // Update validation status if we have a recipient count
        if (result.recipientCount > 0) {
          document.getElementById('validationSheet').textContent = sheetName;
          document.getElementById('validationRecipientCount').textContent = result.recipientCount;
          toggleVisibility('validationStatusGroup', true);
          
          // Add recipient count toast notification
          showNotification(`Found ${result.recipientCount} potential recipients`, 'success', config.toastDuration);
        }
        
        // Apply pending configuration if available
        if (window.pendingConfiguration && window.pendingConfiguration.emailColumn) {
          // Set the email column dropdown
          selectOptionByValue(document.getElementById('emailColumnSelect'), window.pendingConfiguration.emailColumn);
          
          // Update the email column and trigger recipient count update
          spreadsheetData.emailColumn = window.pendingConfiguration.emailColumn;
          updateRecipientCount();
          
          // Show CC/BCC options if needed
          if (window.pendingConfiguration.ccColumn || window.pendingConfiguration.bccColumn) {
            if (document.getElementById('ccColumnGroup').classList.contains('hidden')) {
              toggleCcBcc();
            }
            
            // Set CC column if specified
            if (window.pendingConfiguration.ccColumn) {
              selectOptionByValue(document.getElementById('ccColumnSelect'), window.pendingConfiguration.ccColumn);
            }
            
            // Set BCC column if specified
            if (window.pendingConfiguration.bccColumn) {
              selectOptionByValue(document.getElementById('bccColumnSelect'), window.pendingConfiguration.bccColumn);
            }
          }
          
          // Clear the pending configuration since we've applied it
          window.pendingConfiguration = null;
          
          // Show a message that setup is complete
          showNotification('Configuration setup complete. You can now send emails.', 'success', config.toastDuration);
        }
        
        // Update button states
        updateButtonStates();
      })
      .withFailureHandler(function(error) {
        // Remove loading notification
        if (loadingNotification) {
          loadingNotification.remove();
        }
        
        // Restore button state
        loadColumnsBtn.innerHTML = btnText;
        loadColumnsBtn.disabled = false;
        
        // Show error
        showNotification('Error loading columns: ' + (error.message || 'Unknown error'), 'error', config.toastDuration);
      })
      .getColumnsAndRecipientCount(spreadsheetData.id, sheetName);
  }

  // Handler for sheet columns
  function handleSheetColumns(headers) {
    // Filter out error messages
    const validHeaders = headers.filter(header => !header.startsWith('Error:'));
    
    // Store headers
    spreadsheetData.columnHeaders = validHeaders;
    
    // Populate Recipients Column dropdown
    const emailColumnSelect = document.getElementById('emailColumnSelect');
    emailColumnSelect.innerHTML = '<option value="">Select recipients column...</option>';
    
    // Populate CC Column dropdown
    const ccColumnSelect = document.getElementById('ccColumnSelect');
    ccColumnSelect.innerHTML = '<option value="">None (Optional)</option>';
    
    // Populate BCC Column dropdown
    const bccColumnSelect = document.getElementById('bccColumnSelect');
    bccColumnSelect.innerHTML = '<option value="">None (Optional)</option>';
    
    // Add options for each header to all dropdowns
    validHeaders.forEach(header => {
      // Add to Recipients dropdown
      const emailOption = document.createElement('option');
      emailOption.value = header;
      emailOption.textContent = header;
      emailColumnSelect.appendChild(emailOption);
      
      // Add to CC dropdown
      const ccOption = document.createElement('option');
      ccOption.value = header;
      ccOption.textContent = header;
      ccColumnSelect.appendChild(ccOption);
      
      // Add to BCC dropdown
      const bccOption = document.createElement('option');
      bccOption.value = header;
      bccOption.textContent = header;
      bccColumnSelect.appendChild(bccOption);
    });
    
    // Show recipient column dropdown
    toggleVisibility('emailColumnGroup', true);
    
    // Update placeholders list
    updatePlaceholdersList();
  }

  // Modified function to toggle CC/BCC fields visibility
  function toggleCcBcc() {
    const link = document.getElementById('showCcBccLink');
    const isCcBccVisible = !document.getElementById('ccColumnGroup').classList.contains('hidden');
    
    // Toggle visibility
    if (isCcBccVisible) {
      // Hide the CC/BCC fields
      toggleVisibility('ccColumnGroup', false);
      toggleVisibility('bccColumnGroup', false);
      link.textContent = '+ Show CC/BCC options';
    } else {
      // Show the CC/BCC fields
      toggleVisibility('ccColumnGroup', true);
      toggleVisibility('bccColumnGroup', true);
      link.textContent = '− Hide CC/BCC options';
    }
    
    // Update summary
    updateSummary();
  }

  // Function to update placeholders list
  function updatePlaceholdersList() {
    const placeholdersList = document.getElementById('placeholdersList');
    placeholdersList.innerHTML = '';
    
    if (spreadsheetData.columnHeaders && spreadsheetData.columnHeaders.length > 0) {
      spreadsheetData.columnHeaders.forEach(header => {
        const placeholderItem = document.createElement('div');
        placeholderItem.style.padding = '6px 8px';
        placeholderItem.style.borderBottom = '1px solid #dadce0';
        placeholderItem.style.cursor = 'pointer';
        placeholderItem.textContent = '{{' + header + '}}';
        placeholderItem.onclick = function() {
          copyToClipboard('{{' + header + '}}');
        };
        placeholderItem.setAttribute('role', 'button');
        placeholderItem.setAttribute('tabindex', '0');
        placeholderItem.setAttribute('aria-label', 'Copy placeholder ' + header);
        placeholdersList.appendChild(placeholderItem);
      });
    } else {
      placeholdersList.innerHTML = '<div style="padding: 8px; color: #5f6368; font-style: italic;">No columns found</div>';
    }
  }

  // Update subject line character counter
  function updateCharCounter() {
    const subjectLine = document.getElementById('subjectLine').value;
    const charLength = subjectLine.length;
    const charLimit = config.subjectCharLimit;
    const charCounter = document.getElementById('charCounter');
    
    // Update the counter text
    charCounter.textContent = `${charLength}/${charLimit} characters`;
    
    // Update counter styling based on length
    if (charLength > charLimit) {
      charCounter.className = 'char-counter over-limit';
    } else if (charLength > charLimit * config.subjectWarningThreshold) {
      charCounter.className = 'char-counter warning';
    } else {
      charCounter.className = 'char-counter';
    }
  }

  // Function to copy text to clipboard
  function copyToClipboard(text) {
    const textArea = document.createElement('textarea');
    textArea.value = text;
    document.body.appendChild(textArea);
    textArea.select();
    document.execCommand('copy');
    document.body.removeChild(textArea);
    
    // Show a notification
    showNotification('Copied: ' + text, 'success', config.toastDuration);
  }

  // Function to open the spreadsheet in browser
  function openSpreadsheetInBrowser() {
    if (!spreadsheetData.url) {
      showNotification('Spreadsheet URL not available', 'error', config.toastDuration);
      return;
    }
    
    // Open the original URL directly in a new tab
    window.open(spreadsheetData.url, '_blank');
  }

  // Function to update the recipient count when email column changes
  function updateRecipientCount() {
    const emailColumn = document.getElementById('emailColumnSelect').value;
    if (!emailColumn || !spreadsheetData.id || !spreadsheetData.sheetName) {
      const summaryRecipientCount = document.getElementById('summaryRecipientCount');
      if (summaryRecipientCount) {
        summaryRecipientCount.textContent = '-';
      }
      return;
    }
    
    // Store the selected email column
    spreadsheetData.emailColumn = emailColumn;
    
    // Show loading state
    const summaryRecipientCount = document.getElementById('summaryRecipientCount');
    if (summaryRecipientCount) {
      summaryRecipientCount.textContent = 'Loading...';
    }
    
    google.script.run
      .withSuccessHandler(function(count) {
        // Store the recipient count
        spreadsheetData.recipientCount = count;
        
        // Update UI
        if (summaryRecipientCount) {
          summaryRecipientCount.textContent = count;
        }
        
        // Update quota display with new recipient count
        updateQuotaDisplay();
        
        // Add toast notification for recipient count
        showNotification(`Found ${count} potential recipients in the "${emailColumn}" column`, 'info', config.toastDuration);
        
        // Update validation level and button states
        updateButtonStates();
      })
      .withFailureHandler(function(error) {
        // Show error
        if (summaryRecipientCount) {
          summaryRecipientCount.textContent = 'Error';
        }
        console.error('Error counting recipients:', error);
        
        // Show error notification
        showNotification('Error determining recipient count', 'error', config.toastDuration);
      })
      .getRecipientCount(spreadsheetData.id, spreadsheetData.sheetName, emailColumn);
  }

  // Function to send a test email
  function sendTestEmail() {
    const testEmail = document.getElementById('testEmailAddress').value.trim();
    if (!testEmail) {
      showNotification('Please enter your email address for the test', 'error', config.toastDuration);
      return;
    }
    
    const subjectLine = document.getElementById('subjectLine').value.trim();
    if (!subjectLine) {
      showNotification('Please enter a subject line', 'error', config.toastDuration);
      return;
    }
    
    // Validate minimum requirements for test email
    if (!spreadsheetData.id || !spreadsheetData.sheetName) {
      showNotification('Please validate spreadsheet and select a sheet first', 'error', config.toastDuration);
      return;
    }
    
    // Show loading state
    const sendPreviewBtn = document.getElementById('sendPreviewBtn');
    sendPreviewBtn.disabled = true;
    
    // Add spinner next to button text without changing button size
    const btnText = sendPreviewBtn.textContent || sendPreviewBtn.innerText;
    sendPreviewBtn.innerHTML = `<span class="spinner" style="width: 12px; height: 12px; margin-right: 4px;"></span> ${btnText}`;
    
    // Show loading notification
    const loadingNotification = showNotification('Sending test email...', 'info', 0);
    
    const fromEmail = document.getElementById('fromEmailSelect').value;
    const senderDisplayName = document.getElementById('fromName').value; // Changed to senderDisplayName in server side
    
    // Get CC/BCC from fields if available
    const cc = document.getElementById('ccField') ? document.getElementById('ccField').value : '';
    const bcc = document.getElementById('bccField') ? document.getElementById('bccField').value : '';
    
    // Add debugging
    console.log('Sending test email to:', testEmail);
    console.log('Subject:', subjectLine);
    console.log('From:', fromEmail);
    console.log('Display name:', senderDisplayName);
    
    // Set timeout to prevent infinite waiting
    const timeoutDuration = 30000; // 30 seconds
    let isComplete = false;
    const timeoutId = setTimeout(() => {
      if (!isComplete) {
        // Restore button state
        sendPreviewBtn.innerHTML = btnText;
        sendPreviewBtn.disabled = false;
        
        // Remove loading notification
        if (loadingNotification) {
          loadingNotification.remove();
        }
        
        showNotification('Test email operation timed out. Please try again.', 'error', config.toastDuration);
      }
    }, timeoutDuration);
    
    google.script.run
      .withSuccessHandler(function(result) {
        isComplete = true;
        clearTimeout(timeoutId);
        
        // Add detailed logging
        console.log('Test email result:', result);
        
        // Restore button state
        sendPreviewBtn.innerHTML = btnText;
        sendPreviewBtn.disabled = false;
        
        // Remove loading notification
        if (loadingNotification) {
          loadingNotification.remove();
        }
        
        if (result.success) {
          showNotification('Test email sent to ' + testEmail, 'success', config.toastDuration);
        } else {
          showNotification(result.message || 'Error sending test email', 'error', config.toastDuration);
        }
      })
      .withFailureHandler(function(error) {
        isComplete = true;
        clearTimeout(timeoutId);
        
        // Add detailed logging
        console.error('Test email error:', error);
        
        // Restore button state
        sendPreviewBtn.innerHTML = btnText;
        sendPreviewBtn.disabled = false;
        
        // Remove loading notification
        if (loadingNotification) {
          loadingNotification.remove();
        }
        
        // Show error
        showNotification('Error sending test email: ' + (error.message || 'Unknown error'), 'error', config.toastDuration);
      })
      // Use updated parameter name: senderDisplayName instead of fromName
      .sendTestEmailWithData(testEmail, subjectLine, fromEmail, senderDisplayName, cc, bcc, {
        replacePlaceholders: true,
        spreadsheetId: spreadsheetData.id, 
        sheetName: spreadsheetData.sheetName
      });
  }

  // Function to execute mail merge
  function executeMailMerge() {
    if (!spreadsheetData.id || !spreadsheetData.sheetName) {
      showNotification('Please select a spreadsheet and sheet first', 'error', config.toastDuration);
      return;
    }
    
    const emailColumn = document.getElementById('emailColumnSelect').value;
    if (!emailColumn) {
      showNotification('Please select a recipients column', 'error', config.toastDuration);
      return;
    }
    
    const subjectLine = document.getElementById('subjectLine').value.trim();
    if (!subjectLine) {
      showNotification('Please enter a subject line', 'error', config.toastDuration);
      return;
    }
    
    // Add quota check before sending (if we have permission)
    if (quotaInfo.hasPermission && quotaInfo.remaining > 0 && spreadsheetData.recipientCount > quotaInfo.remaining) {
      // Show a confirmation dialog
      const confirmResult = confirm(
        `Warning: This mail merge will exceed your daily quota.\n\n` +
        `You are trying to send ${spreadsheetData.recipientCount} emails but only have ${quotaInfo.remaining} remaining.\n\n` +
        `Would you like to send only ${quotaInfo.remaining} emails now (up to your quota limit)?`
      );
      
      if (!confirmResult) {
        // User canceled
        return;
      }
      
      // If user confirms, we proceed but add a notification
      showNotification('Mail merge will be limited to your available quota', 'warning', config.toastDuration);
    }
    
    const fromEmail = document.getElementById('fromEmailSelect').value;
    const senderDisplayName = document.getElementById('fromName').value; // Changed to senderDisplayName in server side
    
    // Store column selections
    spreadsheetData.emailColumn = emailColumn;
    spreadsheetData.ccColumn = document.getElementById('ccColumnSelect').value;
    spreadsheetData.bccColumn = document.getElementById('bccColumnSelect').value;
    
    // Show loading state
    const executeBtn = document.getElementById('executeBtn');
    executeBtn.disabled = true;
    
    // Add spinner next to button text without changing button size
    const btnText = executeBtn.textContent || executeBtn.innerText;
    executeBtn.innerHTML = `<span class="spinner" style="width: 12px; height: 12px; margin-right: 4px;"></span> ${btnText}`;
    
    // Show progress indicator
    toggleVisibility('executionProgress', true);
    toggleVisibility('mergeResults', false);
    
    // Update progress (simulate for now)
    simulateProgress();
    
    // Get CC/BCC from fields if available
    const options = {
      cc: document.getElementById('ccField') ? document.getElementById('ccField').value : '',
      bcc: document.getElementById('bccField') ? document.getElementById('bccField').value : '',
      ccColumn: spreadsheetData.ccColumn,
      bccColumn: spreadsheetData.bccColumn,
      batchSize: 50 // Process emails in batches of 50
    };
    
    // Update summary
    updateSummary();
    
    // Show notification
    showNotification('Starting mail merge process...', 'info', config.toastDuration);
    
    // Execute mail merge with a timeout to prevent UI freezing
    setTimeout(function() {
      google.script.run
        .withSuccessHandler(function(result) {
          // Restore button state
          executeBtn.innerHTML = btnText;
          executeBtn.disabled = false;
          
          // Hide progress
          toggleVisibility('executionProgress', false);
          
          // Handle the result
          handleMailMergeResults(result);
          
          // Refresh quota info after sending
          loadQuotaInfo();
        })
        .withFailureHandler(function(error) {
          // Restore button state
          executeBtn.innerHTML = btnText;
          executeBtn.disabled = false;
          
          // Hide progress
          toggleVisibility('executionProgress', false);
          
          // Show error
          showNotification('Mail merge failed: ' + (error.message || 'Unknown error'), 'error', config.toastDuration);
        })
        // Update to use senderDisplayName instead of fromName
        .executeMailMerge(
          spreadsheetData.id, 
          spreadsheetData.sheetName, 
          emailColumn, 
          subjectLine, 
          fromEmail, 
          senderDisplayName, 
          options
        );
    }, 100);
  }

  // Function to simulate progress during mail merge execution
  function simulateProgress() {
    let progress = 0;
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    
    if (!progressBar || !progressText) return;
    
    const interval = setInterval(function() {
      if (progress >= 95) {
        clearInterval(interval);
        return;
      }
      
      // Increase progress by a random amount
      progress += Math.random() * 5;
      if (progress > 95) progress = 95;
      
      // Update progress bar and text
      progressBar.style.width = progress + '%';
      
      // Update text every 25%
      if (progress < 25) {
        progressText.textContent = 'Preparing mail merge...';
      } else if (progress < 50) {
        progressText.textContent = 'Processing data...';
      } else if (progress < 75) {
        progressText.textContent = 'Sending emails...';
      } else {
        progressText.textContent = 'Finalizing...';
      }
    }, 500);
    
    // Store interval ID so we can clear it if needed
    window.progressInterval = interval;
  }

  // Handler for mail merge results
  function handleMailMergeResults(result) {
    const resultsDiv = document.getElementById('mergeResults');
    const resultsIcon = document.getElementById('resultsIcon');
    const resultsTitle = document.getElementById('resultsTitle');
    const resultsDetails = document.getElementById('resultsDetails');
    const errorEmails = document.getElementById('errorEmails');
    
    if (!resultsDiv || !resultsIcon || !resultsTitle || !resultsDetails) return;
    
    if (result.success) {
      // Set results info
      resultsDiv.className = 'alert alert-success';
      resultsIcon.textContent = '✓';
      resultsTitle.textContent = 'Mail merge completed!';
      resultsDetails.textContent = `Sent: ${result.sent} | Errors: ${result.errors}`;
      
      // Add quota limitation info if applicable
      if (result.quotaLimited) {
        resultsDetails.textContent += ` (Limited by quota)`;
      }
      
      // Show notification
      showNotification(`Mail merge complete. Sent: ${result.sent}, Errors: ${result.errors}`, 'success', config.toastDuration);
      
      // Show error emails if any
      if (errorEmails && result.errors > 0 && result.errorEmails) {
        errorEmails.textContent = `Failed emails: ${result.errorEmails}`;
        toggleVisibility('errorEmails', true);
      } else if (errorEmails) {
        toggleVisibility('errorEmails', false);
      }
    } else {
      resultsDiv.className = 'alert alert-error';
      resultsIcon.textContent = '✗';
      resultsTitle.textContent = 'Mail merge failed';
      resultsDetails.textContent = result.message || 'An error occurred during mail merge';
      
      if (errorEmails) {
        toggleVisibility('errorEmails', false);
      }
      
      // Show notification
      showNotification('Mail merge failed: ' + (result.message || 'Unknown error'), 'error', config.toastDuration);
    }
    
    // Show results
    toggleVisibility('mergeResults', true);
  }
  
  // Function to synchronize UI with spreadsheetData
  function syncUIWithData() {
    // Update spreadsheet URL field
    const spreadsheetUrlField = document.getElementById('spreadsheetUrl');
    if (spreadsheetUrlField && spreadsheetData.url) {
      spreadsheetUrlField.value = spreadsheetData.url;
    }
    
    // Update sheet select if available
    if (spreadsheetData.sheetName) {
      const sheetSelect = document.getElementById('sheetSelect');
      if (sheetSelect) {
        // If sheet options aren't loaded yet, we'll handle this in pendingConfiguration
        if (sheetSelect.options.length > 1) {
          selectOptionByValue(sheetSelect, spreadsheetData.sheetName);
        }
      }
    }
    
    // Update email column select if available
    if (spreadsheetData.emailColumn) {
      const emailColumnSelect = document.getElementById('emailColumnSelect');
      if (emailColumnSelect) {
        // If column options aren't loaded yet, we'll handle this in pendingConfiguration
        if (emailColumnSelect.options.length > 1) {
          selectOptionByValue(emailColumnSelect, spreadsheetData.emailColumn);
        }
      }
    }
    
    // Update CC/BCC columns if available
    if (spreadsheetData.ccColumn) {
      const ccColumnSelect = document.getElementById('ccColumnSelect');
      if (ccColumnSelect && ccColumnSelect.options.length > 1) {
        selectOptionByValue(ccColumnSelect, spreadsheetData.ccColumn);
      }
    }
    
    if (spreadsheetData.bccColumn) {
      const bccColumnSelect = document.getElementById('bccColumnSelect');
      if (bccColumnSelect && bccColumnSelect.options.length > 1) {
        selectOptionByValue(bccColumnSelect, spreadsheetData.bccColumn);
      }
    }
    
    // Show/hide load buttons as needed
    if (spreadsheetData.id) {
      toggleVisibility('loadSheetsGroup', true);
    }
    
    if (spreadsheetData.sheetName) {
      toggleVisibility('loadColumnsGroup', true);
    }
    
    // Update spreadsheet info display
    updateSpreadsheetInfoDisplay();
    
    // Update validation state and buttons
    updateButtonStates();
  }
  
  // Function to update spreadsheetData from UI
  function updateDataFromUI() {
    // Get values from UI
    const spreadsheetUrl = document.getElementById('spreadsheetUrl').value.trim();
    const sheetName = document.getElementById('sheetSelect').value;
    const emailColumn = document.getElementById('emailColumnSelect').value;
    const ccColumn = document.getElementById('ccColumnSelect').value;
    const bccColumn = document.getElementById('bccColumnSelect').value;
    
    // Update spreadsheetData
    spreadsheetData.url = spreadsheetUrl;
    
    // Don't update ID here - that happens via validation
    
    if (sheetName) {
      spreadsheetData.sheetName = sheetName;
    }
    
    if (emailColumn) {
      spreadsheetData.emailColumn = emailColumn;
    }
    
    if (ccColumn) {
      spreadsheetData.ccColumn = ccColumn;
    }
    
    if (bccColumn) {
      spreadsheetData.bccColumn = bccColumn;
    }
    
    // Update validation state and buttons
    updateButtonStates();
  }
  
  // Function to load sender emails with better error handling
  function loadSenderEmails() {
    // Show loading notification
    const loadingNotification = showNotification('Loading sender information...', 'info', 0);
    
    google.script.run
      .withSuccessHandler(function(emails) {
        // Remove loading notification
        if (loadingNotification) {
          loadingNotification.remove();
        }
        
        // Check if we got an error response
        if (emails && emails.length > 0 && emails[0].error) {
          // Show permission error but still continue with empty values
          showNotification('Permission error: ' + emails[0].error, 'warning', config.toastDuration * 2);
          console.warn('Permission error loading sender info:', emails[0].error);
        }
        
        // Handle the result (even with errors, we'll have at least one email record)
        handleSenderEmails(emails);
        
        // Also use the user's email for test email field if available
        if (emails && emails.length > 0 && emails[0].email) {
          const testEmailField = document.getElementById('testEmailAddress');
          if (testEmailField) {
            testEmailField.value = emails[0].email || '';
          }
        }
      })
      .withFailureHandler(function(error) {
        // Remove loading notification
        if (loadingNotification) {
          loadingNotification.remove();
        }
        
        // Log the error for debugging
        console.error('Server error loading sender information:', error);
        
        // Show error with more helpful explanation
        showNotification(
          'Error loading sender information. The add-on may need additional permissions.', 
          'error', 
          config.toastDuration
        );
        
        // Use fallback values for sender
        handleSenderEmails([{
          email: '',
          name: 'Mail Merge User',
          isPrimary: true
        }]);
      })
      .getAvailableFromAddresses();
  }
  
  // Handler for sender emails with improved error handling
  function handleSenderEmails(emails) {
    const fromEmailSelect = document.getElementById('fromEmailSelect');
    if (!fromEmailSelect) return;
    
    // Clear existing options
    fromEmailSelect.innerHTML = '';
    
    // Check if we got any valid emails
    if (!emails || emails.length === 0 || !emails[0].email) {
      // Add a placeholder if there's a permission issue or no emails
      const option = document.createElement('option');
      option.value = '';
      option.textContent = 'Use default sender (permission required)';
      fromEmailSelect.appendChild(option);
      
      // Set default sender name with a helpful placeholder
      const senderNameField = document.getElementById('fromName');
      if (senderNameField) {
        senderNameField.value = 'Mail Merge Sender';
        senderNameField.placeholder = 'Enter your name here';
      }
    } else {
      // Add options for each email
      emails.forEach(email => {
        const option = document.createElement('option');
        option.value = email.email;
        option.textContent = email.isPrimary ? 
          `${email.email} (Default)` : 
          `${email.email} (${email.name || 'Delegated'})`;
        fromEmailSelect.appendChild(option);
      });
      
      // Set default sender name if available
      if (emails.length > 0 && emails[0].name) {
        const senderNameField = document.getElementById('fromName');
        if (senderNameField) {
          senderNameField.value = emails[0].name;
        }
      } else {
        getUserName();
      }
    }
    
    // Update summary
    updateSummary();
  }

  // Function to get user name
  function getUserName() {
    google.script.run
      .withSuccessHandler(function(name) {
        const senderNameField = document.getElementById('fromName');
        if (senderNameField) {
          senderNameField.value = name;
        }
        updateSummary();
      })
      .withFailureHandler(function(error) {
        showNotification('Error loading user name: ' + (error.message || 'Unknown error'), 'error', config.toastDuration);
      })
      .getUserName();
  }

  // Function to update sender name based on selected email
  function updateSenderName() {
    // This would be more complex with delegated addresses
    // Here we'll just keep the name as is or get it again if empty
    const senderNameField = document.getElementById('fromName');
    if (senderNameField && !senderNameField.value) {
      getUserName();
    }
    
    // Update summary
    updateSummary();
  }

  // Modified function to update summary with subject line
  function updateSummary() {
    // Safely get current values
    const getElementValue = function(id) {
      const element = document.getElementById(id);
      return element ? element.value : '';
    };
    
    // Get current values
    const emailColumn = getElementValue('emailColumnSelect');
    const ccColumn = getElementValue('ccColumnSelect');
    const bccColumn = getElementValue('bccColumnSelect');
    const fromEmail = getElementValue('fromEmailSelect');
    // Changed name from 'fromName' to 'senderDisplayName' in backend,
    // but UI still uses 'fromName' for backward compatibility
    const senderDisplayName = getElementValue('fromName');
    const subjectLine = getElementValue('subjectLine');
    
    // Update summary display
    const updateElementText = function(id, text) {
      const element = document.getElementById(id);
      if (element) element.textContent = text || '-';
    };
    
    updateElementText('summarySheet', spreadsheetData.sheetName);
    updateElementText('summaryEmailColumn', emailColumn);
    updateElementText('summaryCcColumn', ccColumn);
    updateElementText('summaryBccColumn', bccColumn);
    updateElementText('summaryFromName', senderDisplayName);
    updateElementText('summaryFromEmail', fromEmail);
    updateElementText('summarySubject', subjectLine);
    
    // Update recipient count if email column changed
    if (emailColumn && spreadsheetData.sheetName && spreadsheetData.id) {
      if (spreadsheetData.emailColumn !== emailColumn) {
        spreadsheetData.emailColumn = emailColumn;
        updateRecipientCount();
      }
    } else {
      updateElementText('summaryRecipientCount', '-');
    }
    
    // Update quota display
    updateQuotaDisplay();
  }

  // Load configuration list into the sidebar
  function loadConfigurationList() {
    const configSelect = document.getElementById('configSelect');
    configSelect.innerHTML = '<option value="">Select a configuration...</option>';
    
    google.script.run
      .withSuccessHandler(function(configs) {
        window.availableConfigs = configs; // Store for later use
        
        if (configs && Object.keys(configs).length > 0) {
          for (const name in configs) {
            const option = document.createElement('option');
            option.value = name;
            option.textContent = name;
            configSelect.appendChild(option);
          }
          
          showNotification('Configuration list refreshed', 'info', config.toastDuration);
        } else {
          showNotification('No saved configurations found', 'info', config.toastDuration);
        }
      })
      .withFailureHandler(function(error) {
        showNotification('Error loading configurations: ' + error.message, 'error', config.toastDuration);
      })
      .getAvailableConfigurations();
  }

  // Load selected configuration into the UI fields and spreadsheetData
  function loadSelectedConfig() {
    const configName = document.getElementById('configSelect').value;
    if (!configName) {
      showNotification('Please select a configuration', 'error', config.toastDuration);
      return;
    }
    
    const selectedConfig = window.availableConfigs[configName];
    if (!selectedConfig) {
      showNotification('Configuration not found', 'error', config.toastDuration);
      return;
    }
    
    // Show loading notification
    showNotification(`Loading configuration "${configName}" settings...`, 'info', config.toastDuration);
    
    google.script.run
      .withSuccessHandler(function(result) {
        if (result.success) {
          // Set flag to refresh configurations when returning to sidebar
          google.script.run.setConfigurationRefreshFlag();
          
          showNotification(`Configuration "${configName}" settings loaded`, 'success', config.toastDuration);
          
          // Update UI elements based on the loaded configuration
          updateUIFromConfig(result.config);
          
          // Show indicator of which config is active
          document.getElementById('activeConfigName').textContent = configName;
          document.getElementById('activeConfigIndicator').classList.remove('hidden');
          
          // Validate the loaded configuration
          validateLoadedConfiguration(result.config);
        } else {
          showNotification(result.message || 'Error loading configuration', 'error', config.toastDuration);
        }
      })
      .withFailureHandler(function(error) {
        showNotification(error.message || 'Error loading configuration', 'error', config.toastDuration);
      })
      .loadConfiguration(configName, false); // false = don't load document content
  }

  // Function to validate a loaded configuration
  function validateLoadedConfiguration(config) {
    // Skip if no configuration
    if (!config) return;
    
    // Show "validating configuration" message
    showNotification('Validating configuration settings...', 'info', config.toastDuration);
    
    // Store spreadsheet info - validation will be done automatically once this is set
    if (config.spreadsheetUrl) {
      spreadsheetData.url = config.spreadsheetUrl;
    }
  }

  // Function to update UI from configuration - updated to also update spreadsheetData
  function updateUIFromConfig(config) {
    // Log the config for debugging
    console.log('Updating UI with config:', config);
    
    // Update spreadsheetData directly - keeping original URL
    spreadsheetData.url = config.spreadsheetUrl || '';
    
    // The ID will be extracted internally during validation
    // We'll handle the rest in pendingConfiguration
    
    // Set values in UI fields without attempting validation
    if (config.spreadsheetUrl) {
      document.getElementById('spreadsheetUrl').value = config.spreadsheetUrl;
    }
    
    // Store sheet and column values that will be used after validation
    if (config.sheetName) {
      window.pendingConfiguration = window.pendingConfiguration || {};
      window.pendingConfiguration.sheetName = config.sheetName;
      
      // Also store in spreadsheetData for future use
      spreadsheetData.sheetName = config.sheetName;
    }
    
    if (config.emailColumn) {
      window.pendingConfiguration = window.pendingConfiguration || {};
      window.pendingConfiguration.emailColumn = config.emailColumn;
      
      // Also store in spreadsheetData for future use
      spreadsheetData.emailColumn = config.emailColumn;
    }
    
    // Store CC/BCC values for later
    if (config.ccColumn) {
      window.pendingConfiguration = window.pendingConfiguration || {};
      window.pendingConfiguration.ccColumn = config.ccColumn;
      
      // Also store in spreadsheetData for future use
      spreadsheetData.ccColumn = config.ccColumn;
    }
    
    if (config.bccColumn) {
      window.pendingConfiguration = window.pendingConfiguration || {};
      window.pendingConfiguration.bccColumn = config.bccColumn;
      
      // Also store in spreadsheetData for future use
      spreadsheetData.bccColumn = config.bccColumn;
    }
    
    // Set remaining fields that don't require validation
    // Note: The backend uses 'senderDisplayName', but the UI still uses 'fromName'
    // for backward compatibility
    if (config.fromName) {
      document.getElementById('fromName').value = config.fromName;
    }
    
    if (config.fromEmail) {
      selectOptionByValue(document.getElementById('fromEmailSelect'), config.fromEmail);
    }
    
    if (config.subjectLine) {
      document.getElementById('subjectLine').value = config.subjectLine;
      updateCharCounter();
    }
    
    // Set CC/BCC override fields if they exist
    if (config.ccOverride && document.getElementById('ccField')) {
      document.getElementById('ccField').value = config.ccOverride;
    }
    
    if (config.bccOverride && document.getElementById('bccField')) {
      document.getElementById('bccField').value = config.bccOverride;
    }
    
    // Show validation needed message
    showNotification('Configuration loaded. Click "Validate Spreadsheet" to continue setup.', 'info', 10000);
    
    // Update summary
    updateSummary();
    
    // Show active configuration indicator
    document.getElementById('activeConfigName').textContent = config.templateName || '';
    document.getElementById('activeConfigIndicator').classList.remove('hidden');
    
    // Trigger spreadsheet validation if URL is set
    if (config.spreadsheetUrl) {
      validateSpreadsheet();
    }
  }

  // Clear all fields
  function clearAllFields() {
    if (confirm('Are you sure you want to reset all fields?')) {
      // Reset fields
      document.getElementById('spreadsheetUrl').value = '';
      document.getElementById('sheetSelect').innerHTML = '<option value="">Select a sheet...</option>';
      document.getElementById('emailColumnSelect').innerHTML = '<option value="">Select recipients column...</option>';
      document.getElementById('ccColumnSelect').innerHTML = '<option value="">None (Optional)</option>';
      document.getElementById('bccColumnSelect').innerHTML = '<option value="">None (Optional)</option>';
      document.getElementById('subjectLine').value = '';
      document.getElementById('testEmailAddress').value = '';
      
      // Hide conditional sections
      toggleVisibility('sheetSelectGroup', false);
      toggleVisibility('emailColumnGroup', false);
      toggleVisibility('ccColumnGroup', false);
      toggleVisibility('bccColumnGroup', false);
      toggleVisibility('ccBccToggleGroup', false);
      toggleVisibility('validationStatusGroup', false);
      toggleVisibility('loadSheetsGroup', false);
      toggleVisibility('loadColumnsGroup', false);
      
      // Hide active config indicator
      document.getElementById('activeConfigIndicator').classList.add('hidden');
      
      // Reset dropdown
      document.getElementById('configSelect').value = '';
      
      // Reset data
      spreadsheetData = {
        id: '',
        name: '',
        url: '',
        sheetName: '',
        columnHeaders: [],
        emailColumn: '',
        ccColumn: '',
        bccColumn: '',
        validationResults: null,
        recipientCount: 0
      };
      
      // Update UI
      updateCharCounter();
      updateSummary();
      updateSpreadsheetInfoDisplay();
      
      // Update button states
      updateButtonStates();
      
      showNotification('All fields reset', 'info', config.toastDuration);
    }
  }

  // Helper to select option by value
  function selectOptionByValue(selectElement, value) {
    if (!selectElement) return false;
    
    for (let i = 0; i < selectElement.options.length; i++) {
      if (selectElement.options[i].value === value) {
        selectElement.selectedIndex = i;
        // Trigger change event
        const event = new Event('change');
        selectElement.dispatchEvent(event);
        return true;
      }
    }
    
    return false;
  }

  // Helper function to show a notification
  function showNotification(message, type, duration) {
    // Create notification element
    const notificationDiv = document.createElement('div');
    notificationDiv.className = 'alert alert-' + (type || 'info');
    notificationDiv.style.position = 'fixed';
    notificationDiv.style.top = '10px';
    notificationDiv.style.left = '50%';
    notificationDiv.style.transform = 'translateX(-50%)';
    notificationDiv.style.zIndex = '1000';
    notificationDiv.style.boxShadow = '0 2px 10px rgba(0,0,0,0.1)';
    notificationDiv.style.maxWidth = '280px';
    notificationDiv.style.wordWrap = 'break-word';
    notificationDiv.setAttribute('role', 'alert');
    
    // Set icon based on type
    let icon = '⚠';
    if (type === 'success') icon = '✓';
    if (type === 'error') icon = '✗';
    if (type === 'info') icon = 'ℹ';
    
    // Add spinner for loading notifications
    if (duration === 0) {
      icon = '<span class="spinner" style="width: 14px; height: 14px;"></span>';
    }
    
    // Create notification content
    notificationDiv.innerHTML = `
      <div style="display: flex; align-items: center;">
        <div class="alert-icon">${icon}</div>
        <div>${message}</div>
      </div>
    `;
    
    // Add to document
    document.body.appendChild(notificationDiv);
    
    // Remove after duration if specified
    if (duration > 0) {
      setTimeout(function() {
        notificationDiv.style.opacity = '0';
        notificationDiv.style.transition = 'opacity 0.5s';
        setTimeout(function() {
          if (notificationDiv.parentNode) {
            document.body.removeChild(notificationDiv);
          }
        }, 500);
      }, duration);
    }
    
    return notificationDiv;
  }

  
  function setupConfigurationRefreshCheck() {
    // Create debounced version of load function
    const debouncedLoadConfig = debounce(function() {
      google.script.run
        .withSuccessHandler(function(needsRefresh) {
          if (needsRefresh) {
            console.log('Configurations updated, refreshing list...');
            loadConfigurationList();
          }
        })
        .checkConfigurationsNeedRefresh();
    }, 300); // 300ms debounce time
    
    // Check when window regains focus
    window.addEventListener('focus', debouncedLoadConfig);
  }

  // Add this to the document.addEventListener('DOMContentLoaded', function() { section:
  document.addEventListener('DOMContentLoaded', function() {
    try {
      console.log('DOM Content Loaded - Initializing UI');
      
      // Load configuration list
      loadConfigurationList();
      
      // Load sender emails
      loadSenderEmails();
      
      // Load quota info when the page loads (with a small delay to ensure UI elements are ready)
      setTimeout(loadQuotaInfo, 500);
      
      // Set up event listeners
      const setupEventListener = function(id, event, handler) {
        const element = document.getElementById(id);
        if (element) {
          element.addEventListener(event, handler);
        } else {
          console.warn(`Element with ID "${id}" not found for event binding`);
        }
      };
      
      setupEventListener('subjectLine', 'input', function() {
        updateCharCounter();
        updateSummary();
      });
      
      setupEventListener('fromEmailSelect', 'change', updateSummary);
      setupEventListener('fromName', 'input', updateSummary);
      setupEventListener('emailColumnSelect', 'change', updateSummary);
      
      // Add event listeners for CC/BCC dropdowns
      setupEventListener('ccColumnSelect', 'change', updateSummary);
      setupEventListener('bccColumnSelect', 'change', updateSummary);
      
      // Add event listener for spreadsheet URL
      setupEventListener('spreadsheetUrl', 'blur', function() {
        // Update spreadsheetData URL on blur
        spreadsheetData.url = this.value.trim();
      });
      
      // Initialize character counter
      updateCharCounter();
      
      // Set initial tooltip state
      toggleTooltips(config.showTooltips);
      
      // Add keyboard accessibility for placeholder items
      document.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' || e.key === ' ') {
          if (e.target.hasAttribute('role') && e.target.getAttribute('role') === 'button') {
            e.preventDefault();
            e.target.click();
          }
        }
      });
      
      // Setup check for configuration updates
      setupConfigurationRefreshCheck();
      
      console.log('UI initialization completed');
    } catch (error) {
      console.error('Error during initialization:', error);
      alert('There was an error initializing the UI. Please reload the page.');
    }
  });
</script>